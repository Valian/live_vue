import { App, Component, createSSRApp, h } from "vue"
import { renderToString } from "vue/server-renderer"
import { normalizeComponents, getComponent } from "./components"
import fs from "fs"

type Components = Record<string, Component>

// it's of type Live but I can't import it, since types include HTML elements
const mockLive = {
    el: {} as any,
    liveSocket: {} as any,
    pushEvent: () => 0,
    pushEventTo: () => 0,
    handleEvent: () => () => {},
    removeHandleEvent: () => {},
    upload: () => {},
    uploadTo: () => {},
    vue: {
        props: {},
        slots: {},
        app: {} as App<any>,
    },
}

export const getRender = (components: Components) => {
    components = normalizeComponents(components)

    return async (name: string, props: Record<string, any>, slots: Record<string, string>) => {
        const component = await getComponent(components, name)

        const app = createSSRApp({
            render: () =>
                h(
                    component,
                    props,
                    Object.fromEntries(
                        Object.entries(slots).map(([name, html]) => [name, () => h("div", { innerHTML: html })])
                    )
                ),
        })
        // there is no liveSocket or phoneix JS library on the server, so we need to mock it
        app.use({
            install: (app: App) =>
                app.provide("_live_vue", {
                    ...mockLive,
                    vue: {
                        props: slots,
                        slots: props,
                        app: app,
                    },
                }),
        })

        return renderToString(app)
    }
}
/**
 * Loads the manifest file from the given path and returns a record of the assets.
 * Manifest file is a JSON file generated by Vite for the client build.
 * We need to load it to know which files to preload for the given page.
 * @param path - The path to the manifest file.
 * @returns A record of the assets.
 */
export const loadManifest = (path: string): Record<string, string[]> => {
    const manifest = JSON.parse(fs.readFileSync(path, "utf8"))
    return Object.fromEntries(
        Object.entries(manifest).map(([key, value]) => [key, Array.isArray(value) ? value : [value as string]])
    )
}
